from collections import deque
from dataclasses import asdict
from typing import TYPE_CHECKING

import boto3
from domain.core.device import DeviceKeyAddedEvent
from domain.core.event import ExportedEventsTypeDef, ExportedEventTypeDef
from domain.core.load_questionnaire import render_questionnaire
from domain.core.questionnaires import QuestionnaireInstance
from etl_utils.constants import WorkerKey
from etl_utils.io import pkl_dump_lz4, pkl_load_lz4
from etl_utils.smart_open import smart_open
from etl_utils.worker.action import apply_action
from etl_utils.worker.model import WorkerActionResponse, WorkerEnvironment
from etl_utils.worker.worker_step_chain import execute_step_chain
from event.aws.client import dynamodb_client
from sds.cpm_translation import translate

if TYPE_CHECKING:
    from mypy_boto3_s3 import S3Client


S3_CLIENT = boto3.client("s3")
DYNAMODB_CLIENT = dynamodb_client()
ENVIRONMENT = WorkerEnvironment.build()


class DuplicateSdsKey(Exception):
    pass


def reject_duplicate_keys(exported_events: ExportedEventsTypeDef):
    all_keys = set()
    for exported_event in exported_events:
        ((event_name, event),) = exported_event.items()
        if event_name != DeviceKeyAddedEvent.public_name:
            continue
        key = event["key"]
        if key in all_keys:
            event.pop("id")  # field generated by us, so not relevant for debugging
            raise DuplicateSdsKey(event)
        all_keys.add(key)


def transform(
    s3_client: "S3Client", s3_input_path: str, s3_output_path: str
) -> WorkerActionResponse:
    with smart_open(s3_path=s3_input_path, s3_client=s3_client) as f:
        unprocessed_records: deque[dict] = pkl_load_lz4(f)

    with smart_open(s3_path=s3_output_path, s3_client=s3_client) as f:
        processed_records: deque[ExportedEventTypeDef] = pkl_load_lz4(f)

    spine_device_questionnaire = render_questionnaire(
        questionnaire_name=QuestionnaireInstance.SPINE_DEVICE, questionnaire_version=1
    )
    spine_endpoint_questionnaire = render_questionnaire(
        questionnaire_name=QuestionnaireInstance.SPINE_ENDPOINT, questionnaire_version=1
    )

    _spine_device_questionnaire = spine_device_questionnaire.dict()
    _spine_endpoint_questionnaire = spine_endpoint_questionnaire.dict()

    exception = apply_action(
        unprocessed_records=unprocessed_records,
        processed_records=processed_records,
        action=lambda record: translate(
            obj=record,
            spine_device_questionnaire=spine_device_questionnaire,
            _spine_device_questionnaire=_spine_device_questionnaire,
            spine_endpoint_questionnaire=spine_endpoint_questionnaire,
            _spine_endpoint_questionnaire=_spine_endpoint_questionnaire,
            _trust=True,
        ),
    )

    if exception is None:
        reject_duplicate_keys(exported_events=processed_records)

    return WorkerActionResponse(
        unprocessed_records=unprocessed_records,
        processed_records=processed_records,
        exception=exception,
        s3_input_path=s3_input_path,
        s3_output_path=s3_output_path,
    )


def handler(event: dict, context):
    response = execute_step_chain(
        action=transform,
        s3_client=S3_CLIENT,
        s3_input_path=ENVIRONMENT.s3_path(WorkerKey.TRANSFORM),
        s3_output_path=ENVIRONMENT.s3_path(WorkerKey.LOAD),
        unprocessed_dumper=pkl_dump_lz4,
        processed_dumper=pkl_dump_lz4,
    )
    return asdict(response)
